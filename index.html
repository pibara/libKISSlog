<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>LibKISSlog by pibara</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>LibKISSlog</h1>
          <h2>A trivial but powerful C++ logging template-library. </h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/pibara/libKISSlog/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/pibara/libKISSlog/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/pibara/libKISSlog" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h3>The KISS Logging template-library for C++</h3>

<p>LibKISSlog is a trivial light-weight C++ template library that was designed and written according to the KISS ( Keep It Simple &amp; Straightforward) principle. The library leans heavily on the STL for keeping its implementation as simple as its usage, and tries to provide C++ developers with a light-weight, paradigm-pure and flexible alternative to logging libraries that use design and/or implementation decisions that at least the author of LibKISSlog believes to be questionable.</p>
<h2>Using libKISSlog</h2>
<h3>Header and statics.</h3>
If your application is to be a single threaded application, 
or you are using a hand written custom raw logger that is inherantly thread safe, 
than libKISSlog is a header only library. 

Simply add the file <i></i>kisslog.h</i> to one of your inc directories and in your program add an include for it.

<pre><code>#include &lt;kisslog.h&gt;</code></pre>

It is sugested that for single threaded application you'd add a simple typedef to your program right after including kisslog.h.

<pre><code>typedef kisslog::threading::SINGLE concurrency_mode_t</code></pre>

When you plan to log from several threads to a non explicitly thread safe raw logger such as the built-in syslog raw 
logger, than you should do two things. First you should make sure that the file <i>kisslog-mt-static.cpp</i> will get linked with your program.
This file contains a single static definition that is needed in multi threaded operation. Next to this you should change the typedef to:

<pre><code>typedef kisslog::threading::MULTI concurrency_mode_t</code></pre>

<h3>Typedeffing and instantiating your raw logger</h3>
The first thing you will need to do when using libKISSlog is to choose and typedef a propper raw logger. Alternatively you may define your own raw logger, but libKISSlog also comes with two built-in raw loggers that might suite your needs.
<h4>Typedeffing a syslog raw logger</h4>
If your software targets only POSIX (Linux,*BSD,*NIX,etc) systems and not for example MS-Windows, and your software is meant to be
some kind of back-end, server, appliance or other type of daemon type software, than the syslog raw logger is probably most
 suited to your needs. In order to use a syslog logger as our raw logger we shall define a typedef for it.
 
<pre><code>typedef kisslog::rawlogger::sysloglogger&lt;kisslog::facility::USER,concurency_mode_t&gt; raw_logger_t</code></pre>
 
Note that this typedef uses two template parameters. The first template parameter is the so called syslog <i>facility</i> that the rawlogger should use. 
The libKISSlog library defines USER,DAEMON and LOCAL0 .. LOCAL7 as valid facilities for the syslog raw logger. Have a look at the syslog manual to determine 
what facility is most suited for your program. The second template argument is the threading mode that the raw logger should use.
It is sugested that you always use the raw_logger_t typedef that you defined for your program so you can switch concurency mode in just a single place.

In your program you can than instantiate your raw logger:

<pre><code>raw_logger_t rawlogger("demo")</code></pre>

Depending on your system syslog configuration, the constructor argument may be used as a prefix for all your log messages.

<h4>Typedeffing the ostream raw logger</h4>
If the syslog raw logger is not suitable for your needs and your logging needs don't require wide string support, than alternatively
the ostream raw logger may be an option for you. A typedef for an ostream raw logger would look something like:
<pre><code>typedef kisslog::rawlogger::ostreamlogger&lt;concurrency_mode_t&gt; rawlogger_t;</code></pre>

Again we use the concurrency_mode_t as template parameter in our typedef for the rawlogger_t.

In your program you can than instantiate your raw logger:

<pre><code>rawlogger rlogger(std::cerr);</code></pre>

This example uses std::cerr as output stream, but you could use any ostream, for example for logging to a file or a network socket.

<h4>Writing your own custom raw logger.</h4>
<p>If neither of the two built-in raw loggers are suitable for your logging needs, for example you may not like the formatting it does or you might want to log wide strings, 
than writing up your own raw logger class might be needed. Doing so shall give you full control at the price of being a litle bit work to implement.</p>

<p>A raw logger can either be a normal class or a template class that implements a <em>log</em> template method. LibKISSlog defines a set of log levels that are to be used by libKISSlog as template parameters for the <em>log</em> method of the raw logger. 
</p>

<p>Here would be an example of a dumb and useless raw logger that logs to cerr with a line number prepended:</p>

<pre><code>class rawlogger_t {
       size_t mLineno;
   public:
       rawlogger_t():mLineNo(0){}
       template &lt;typename T&gt;
       void log(<b>std::string</b> line) {
          mLineno++;
          std::cerr &lt;&lt; mLineNo &lt;&lt; ":" &lt;&lt; kisslog::severity::asPrefix&lt;T,<b>char</b>&gt;() &lt;&lt; line;
       }
};
</code></pre>

<p>One point of interest in the above code is the usage of <i>kisslog::severity::asPrefix&lt;T,char&gt;()</i>. This basically returns a string representation 
  of the severity level <i>T</i>.
</p>
<h5>threading</h5>
<p>Note that if you write a raw logger that you want to re-use in several projects, especially if you are using thread-unsafe API calls and want to be able to re-use your custom raw logger in both single threaded and multi threaded application, it is sugested that you implement your raw logger as a template class basically like this:</p>

<pre><code>template &lt;typename G&gt;
class base_rawlogger_t {
       size_t mLineno;
   public:
       base_rawlogger_t():mLineNo(0){}
       template &lt;typename T&gt;
       void log(<b>std::string</b> line) {
          threading::guard_if_needed&lt;G&gt; myguard;
          mLineno++;
          std::cerr &lt;&lt; mLineNo &lt;&lt; ":" &lt;&lt; kisslog::severity::asPrefix&lt;T,<b>char</b>&gt;() &lt;&lt; line;
       }
};

typedef base_rawlogger_t&lt;concurency_mode_t&gt; rawlogger_t;
</code></pre>

<p>Now before you instantiate your logger its a good idea to create a typedef approprite for your program:</p>

<pre><code>typedef base_rawlogger_t&lt;concurrency_mode_t&gt; rawlogger_t;
</code></pre>
<h5>wide string support</h5>
Next to supporting multiple concurency modes you might have an application that uses wide strings instead of char based strings.
To accomodate this, libKISSlog, while not supplying wide string based built-in raw loggers, does make it trivial to write
your own. Lets look what a wide string version of our previous raw logger looks like:

<pre><code>template &lt;typename G&gt;
class base_rawlogger_t {
       size_t mLineno;
   public:
       base_rawlogger_t():mLineNo(0){}
       template &lt;typename T&gt;
       void log(<b></b>std::wstring</b> line) {
          threading::guard_if_needed&lt;G&gt; myguard;
          mLineno++;
          std::cerr &lt;&lt; mLineNo &lt;&lt; ":" &lt;&lt; kisslog::severity::asPrefix&lt;T,<b>wchar_t</b>&gt;() &lt;&lt; line;
       }
};
typedef base_rawlogger_t&lt;concurency_mode_t&gt; rawlogger_t;
</code></pre>


<h3>Typedeffing and instantiating our real logger</h3>

<p>So far all we've basically done is defining a type for and instantiating a raw logger that should be used by our 
actual logger. 
The <em>kisslog::logger</em> class template takes 1 to 3 template arguments. The first template argument is the type of 
the raw logger. The second template argument is the <em>minimal</em> log level for this logger for 
what log lines will actually get logged. This second template parameter basically implies that you can switch between 
doing fully verbose debug logging and logging that only does WARNING and above by changing a typedef. The default level is WARNING.
The third and last template argument is the character type this logger is for. This type should match the type used for the
creation of the raw logger.
A real logger typedef may look something like:</p>

<pre><code>typedef kisslog::logger&lt;
          raw_logger_t,
          kisslog::severity::WARNING,
          wchar_t
        &gt; warnlogger_t;
</code></pre>

<p>Now that we have our typedefs in order (myrawlogger and warnlogger), we can instantiate our logger and use it.</p>

<pre><code>myrawlogger rawlogger;
warnlogger_t warnlogger(rawlogger);
..
warnlogger.err() &lt;&lt; L"Logging is simple " &lt;&lt; 42 &lt;&lt; std::endl;
warnlogger.debug() &lt;&lt; L"This line won't be logged." &lt;&lt; std::endl;
</code></pre>

<p>The logger defines a small set of methods, one for each log level, that all return an ostream reference.
Given our typedef for warnlogger_t defining <em>kisslog::severity::WARNING</em> as minimal level for logging, 
the warnlogger.err() method will return a stream reference that maps to our raw logger being invoked, while the 
warnlogger.debug() invocation will return a null stream. The zero argument logging methods that a logger defines are:</p>
<ul>
  <li>debug()</li>
  <li>info()</li>
  <li>notice()</li>
  <li>warning()</li>
  <li>err()</li>
  <li>crit()</li>
  <li>alert()</li>
  <li>emerg()</li>
</ul>
<h3>Word of caution regarding debug logging and performance.</h3>

<p>Please note that while our logger will return null streams that are relatively efficient, the sheer volume of debug logs might turn many operator&lt;&lt;() invocations done in inner loops into a major performance bottleneck. Addressing these issues is beyond the scope of libKISSlog or any other logging library that chooses to use a streaming interface. It is thus sugested that you should probably :</p>

<ul>
<li>Use old and ugly #ifdef constructs for debug logs in inner loops.</li>
<li>Never use logs above the debug level in your inner loops.</li>
</ul><p>Logging code in inner loops should thus look something like this: </p>

<pre><code>   #ifdef DEBUG_INNER_LOOPS
     debuglogger.debug() &lt;&lt; "Log in performance critical inner loops."
   #endif
</code></pre>

<h3>Passing loggers around</h3>

<p>The libKISSlog API does out of principle not supply any singleton interface and does not use any kind of global mutable state under the hood. Instead, libKISSlog promotes the use of constructor based dependency injection. To accomodate this, any concrete kisslog::logger class is a subclass of the abstract <em>kisslog::logger_base</em> class. This basically allows for constructs like:</p>

<pre><code>class Foo {
    kisslog::logger_base &amp;mLogger;
  public:
    Foo(kisslog::logger_base &amp;logger):mLogger(logger) {}
    void testlog() {
        mLogger.debug() &lt;&lt; "Foo has something uninteresting to say" &lt;&lt; std::endl;
        mLogger.crit() &lt;&lt; "Foo is in big problems." &lt;&lt; std::endl;
    }
};
..
Foo foo(warnlogger);
..
foo.testlog();
</code></pre>

<p>Note that Foo does not need to know what type of logger its being passed here. This also, next to making dependencies more explicit (what is good), allows for flexibility in what level of logging is used by what sub systems without using bloated Log4J style frameworks, simply by passing different loggers (with different minimum log levels) to the constructors of the different sub-systems:</p>

<pre><code>Foo foo(warnlogger);
Bar bar(debuglogger);
..
foo.testlog();
bar.testlog();
</code></pre>

<p>In the above situation, foo will not log any DEBUG, INFO or NOTICE level log lines, while bar will.</p>
<h2 id="choose">Why choose libKISSlog?</h2>
There are many C++ and C logging libraries around, so why would you pick libKISSlog and not one of the other ones, 
or do you need a logging library at all, or could you suffice just using the facilities that the STL already offers?
Lets look at a long list of factors that may be important for you when choosing a particular library for your project.
We will start with a list of factors where libKISSlog comes out good.
<h3>No singletons</h3>
Many logging libraries use singletons or other forms of global mutable state. While the singleton pattern is a wel 
known GoF design pattern. A pattern however that has turned out to be a controversial pattern that some consider an
anti-pattern. There are issues with testing, issues with multi-threading, problems from a dependency point of view.
If you also view the singleton pattern and other forms of global mutable state like global variables as bad practice,
than a logging library like libKISSlog may be right for you.
<h3>No macros</h3>
Many C++ coding standards explicitly ban the use of macros. Logging libraries seem to be a place however where the use 
of macros is somehow accepted. The question is, is a piece of basic program infrastructure like a log library worth
letting you sane coding guideline slide? If you are convinced about the sanity of banning macros, using a macro free 
logging library like libKISSlog may be right for you.
<h3>No run time filtering</h3>
C++, other than for example Java, is a language where one of the base paradigms is the use of different techniques for 
moving much of the CPU work to compile-time. If you believe that filtering of log messages based on severity levels 
is something that should happen compile-time, than a template library like libKISSlog may be right fopr you.
<h3>No big framework</h3>
Java is a language of frameworks, people moving from Java to C++ often miss their frameworks, and some C++ logging 
libraries have arissen from this. This while people who moved from more low level languages to C++, or target more 
minimal hardware, often have a strong dislike for these in their view bloated frameworks. If you dislike large 
framework style libraries, than a small and light logging library like libKISSlog may be right for you. 
<h3>Friendly stream based interface</h3>
Streams are undenieable the most programmer friendly way of doing output. A stream however that does not produce 
any output, for example as a result that it is a null-stream, will as a result of its usage pattern, that combines it
with somethime expensive operator<<() invocations, makes the use of streams as basic interface relatively expensive.
In much of the code-base this wont be a problem, but in performance critical inner loops it most definetely will.
If you believe that inner loop logging is a special case, and a questionable use of logging anyway, that doesnt warant 
abandoning the friendly stream based interface, than a logging library like libKISSlog with a friendly stream interface 
may be right for you.
<h3>Template library</h3>
If you enjoy using the STL and maybe some loki or boost library, than you will probably prefer a C++ template library
like libKISSlog over a non template C++ library. 
<h3>Support for multi-threading</h3>
If you are going to log from multiple threads, than you will want a library that like libKISSlog supports multi-threading.
<h3>Support for efficient single threading</h3>
If you sometimes want to log in multi-threaded programs, but at other times don't want to pay the efficiency price of 
thread-safe code when logging from a single thread, than you will probably want a library that like libKISSlog makes 
thread safety optional.  
<h3>Extendable</h3>
If you are the type of user that wants to be able to plug in his/her own log channels, for example logging to an 
encrypted stream, using JSON formatting, etc, than you will want to use an extendable logging solution like libKISSlog 
offers.
<h3>Per sub-system log-level filtering</h3>
If a single filter on log level is not sufficient for you but you want to fine controll what sub-systems would for example log at 
DEBUG level and above and what sub-systems only at NOTICE level and above, than you will want a logging library that like
libKISSlog allows this fine level of control.
<h3>No resource management issues</h3>
In C++ we have the RAII idiom for doing resource management. Unfortunately some log library authors aparently havnt discovered the
joy of using RAII and thus of writing memory leak free code. This should not be a question of taste, you do not want to use
any library that leaks memory. 
<h3>Support for syslog on POSIX systems</h3>
On production server software running on POSIX systems, the convention for logging is to use syslog. If your code targets these
types of systems you will want a logging library like libKISSlog that supports logging to syslog.
<h2>Why NOT choose libKISSlog and alternative libraries.</h2>
Next to reasons why you may want to use libKISSlog for your project, there are also reasons why this library may not be the right solution for you.
<h3>No built-in asynchonous logging</h3>
If you have a system with many concurent threads, the overhead of synchonous metaphor based logging may become a
serious bottleneck. Currently libKISSlog does not support the more efficient actor model based asynchonous logging model
that is suitable for highly concurent applications. If asynchonous logging is esential, you may want to look at <A HREF="https://sites.google.com/site/kjellhedstrom2/g2log-efficient-background-io-processign-with-c11">g2log</A>.
<h3>Not for lovers of singletons.</h3>
If you are part of the large group of C++ developers the use of singletons and other similar shared mutable state 
techniques are simply a fact of life. Adding a loggin library to the mix that <i>demands</i> the use of constructor
based dependency injection may simply be to painstaking for you for libKISSlog to be of practical use. If this 
happens to be the case, you have a wide range of alternative libraries that provide logging in the global namespace.
<h3>Nothing like Log4J</h3>
If you have a Java background and <i>LOVE</i> Log4J, than libKISSlog will bring great sorow for you. The libKISSlog library is absolutely 
nothing like Log4J. If this is the case, there are quite a few bloated Log4J libraries you can choose from, including apaches <A HREF="http://logging.apache.org/log4cxx/">Log4Cxx</A>.
<h3>Inner loop logging</h3>
If you do feel inner loop logging is esential, and the use of #ifdef is a non solution, than libKISSlog is not what you want. 
You may like a logging library like <A HREF="http://www.pantheios.org/">Pantheios</A> instead.
<h3>You may not actually need a full blown logging library.</h3>
If you look at the implementation of libKISSlog you will see that although it has a great list of features, its actually a quite simple 
library. The reason for this is that it makes use of what the STL has to offer, most notably the use of an subclassing of
std::streambuf. When your logging demands are very specific, than although libKISSlog is prety light, it may be overkill still.
You may just want to look at the libKISSlog sources and create your own simple and tailored logging library using these
STL facilities yourself. 
        </section>

        <footer>
          LibKISSlog is maintained by <a href="https://github.com/pibara">pibara</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>
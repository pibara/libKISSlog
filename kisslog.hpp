//  Copyright (c) 2012, Rob J Meijer
//
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.

#ifndef KISSLOG_HPP
#define KISSLOG_HPP
#ifndef WIN32
#include <syslog.h>
#endif

#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L
#include <mutex>
#else
#ifndef WIN32
#include <pthread.h>
#else 
#include <windows.h>
#endif
#endif

#include <string.h>
#include <string>
#include <streambuf>
#include <iostream>
#include <ctime>

namespace kisslog {
  //An list of syslog facilities as simple classes. Note that these are not all possible
  //facilities, just the one a typical user space program will be using.
#ifndef WIN32
  namespace facility {
    struct DAEMON {
      static int asSyslogFacility() {
        return LOG_DAEMON;
      }
    };
    struct LOCAL0 {
      static int asSyslogFacility() {
        return LOG_LOCAL0;
      }
    };
    struct LOCAL1 {
      static int asSyslogFacility() {
        return LOG_LOCAL1;
      }
    };
    struct LOCAL2 {
      static int asSyslogFacility() {
        return LOG_LOCAL2;
      }
    };
    struct LOCAL3 {
      static int asSyslogFacility() {
        return LOG_LOCAL3;
      }
    };
    struct LOCAL4 {
      static int asSyslogFacility() {
        return LOG_LOCAL4;
      }
    };
    struct LOCAL5 {
      static int asSyslogFacility() {
        return LOG_LOCAL5;
      }
    };
    struct LOCAL6 {
      static int asSyslogFacility() {
        return LOG_LOCAL6;
      }
    };
    struct LOCAL7 {
      static int asSyslogFacility() {
        return LOG_LOCAL7;
      }
    };
    struct USER {
      static int asSyslogFacility() {
        return LOG_USER;
      }
    }; 
  }
  namespace util {
    template <typename C>    
    struct CharUtil; 
    template <>
    struct CharUtil<char> {
      char newline() { return '\n';}
      std::basic_string<char> sp_col_sp() { return " : "; }
      std::basic_string<char> now() {
         time_t ctt = time(0);
         std::basic_string<char> timestring=asctime(localtime(&ctt));
         timestring=timestring.substr(0,timestring.size()-1);
         return timestring;
      }
    };
    template <>
    struct CharUtil<wchar_t> {
      char newline() { return L'\n';}
      std::basic_string<wchar_t> sp_col_sp() { return L" : "; }
      //FIXME: we need a wchar_t 'now()' definition also!.
    };

  }
  
#endif
  //Some helper classes for allowing multi threading (in a crude way) only when needed.
  namespace threading {
    struct SINGLE{};
    struct MULTI{};
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L
    class guard {
        static std::mutex mGlobalMutex; 
      public:
        guard() {
          mGlobalMutex.lock();
        }
        ~guard() {
          mGlobalMutex.unlock();
        }       
    };
#else
#ifndef WIN32
    class guard {
        static pthread_mutex_t mGlobalMutex; 
      public:
        guard() {
          pthread_mutex_lock(&mGlobalMutex);
        }
        ~guard() {
          pthread_mutex_unlock(&mGlobalMutex);
        }       
    };
#else
   //Piece of Win32 code contributed by Torsten Schr√∂der
   namespace detail
   {
     class init_guard {
        static CRITICAL_SECTION mGlobalMutex; 
       public:
        init_guard() {
          InitializeCriticalSection(&mGlobalMutex);
        }
        ~init_guard() {
          DeleteCriticalSection(&mGlobalMutex);
        }       
        CRITICAL_SECTION * operator()() { 
          return &mGlobalMutex; 
        }
        const CRITICAL_SECTION * operator()() const { 
          return &mGlobalMutex; 
        }
     };
  } 
  class guard {
      static detail::init_guard mGlobalMutex; 
    public:
      guard() {
        EnterCriticalSection(mGlobalMutex());
      }
      ~guard() {
        LeaveCriticalSection(mGlobalMutex());
      }       
  };
#endif
#endif
    template <typename T>
    class guard_if_needed {};
    template <>
    class guard_if_needed <MULTI> {
        guard mGuard;      
       public:
        guard_if_needed():mGuard(){}
    };
  }
  //A list of log levels as simple classes.
  namespace severity {
    enum Severity {// Numerical codes are from RFC-5424
        EMERG=0, ALERT=1, CRIT=2, ERR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7
    };
    template<Severity,typename C> inline std::basic_string<C> asPrefix();
    template<> inline std::basic_string<char> asPrefix<EMERG,char>(){ return "EMERG"; }
    template<> inline std::basic_string<char> asPrefix<ALERT,char>(){ return "ALERT"; }
    template<> inline std::basic_string<char> asPrefix<CRIT,char>(){ return "CRIT"; }
    template<> inline std::basic_string<char> asPrefix<ERR,char>(){ return "ERR"; }
    template<> inline std::basic_string<char> asPrefix<WARNING,char>(){ return "WARNING"; }
    template<> inline std::basic_string<char> asPrefix<NOTICE,char>(){ return "NOTICE"; }
    template<> inline std::basic_string<char> asPrefix<INFO,char>(){ return "INFO"; }
    template<> inline std::basic_string<char> asPrefix<DEBUG,char>(){ return "DEBUG"; }
    template<> inline std::basic_string<wchar_t> asPrefix<EMERG,wchar_t>(){ return L"EMERG"; }
    template<> inline std::basic_string<wchar_t> asPrefix<ALERT,wchar_t>(){ return L"ALERT"; }
    template<> inline std::basic_string<wchar_t> asPrefix<CRIT,wchar_t>(){ return L"CRIT"; }
    template<> inline std::basic_string<wchar_t> asPrefix<ERR,wchar_t>(){ return L"ERR"; }
    template<> inline std::basic_string<wchar_t> asPrefix<WARNING,wchar_t>(){ return L"WARNING"; }
    template<> inline std::basic_string<wchar_t> asPrefix<NOTICE,wchar_t>(){ return L"NOTICE"; }
    template<> inline std::basic_string<wchar_t> asPrefix<INFO,wchar_t>(){ return L"INFO"; }
    template<> inline std::basic_string<wchar_t> asPrefix<DEBUG,wchar_t>(){ return L"DEBUG"; }
  }
  //Some raw loggers, well one actually, currently.There is only a syslog raw logger now but we could add a stream logger here maybe.
  namespace rawlogger {
#ifndef WIN32
    template <typename F,typename G,typename C>
    class sysloglogger;
    template <typename F,typename G>
    class sysloglogger<F,G,char> {
        std::basic_string<char> mIdent;
        util::CharUtil<char> charutil;
      public:
        sysloglogger(std::basic_string<char> ident):mIdent(ident),charutil() {
          openlog(mIdent.c_str(),LOG_PID, F::asSyslogFacility());    
        } 
        ~sysloglogger() {
           closelog();
        }

        template <severity::Severity S>
        void log(std::basic_string<char> line) {
           threading::guard_if_needed<G> myguard;
           syslog(S,"%s",(severity::asPrefix<S,char>() + charutil.sp_col_sp() + line).c_str());
        }
    };
#endif
    template <typename G, typename C>
    class ostreamlogger {
        std::basic_ostream<C> &mStream;
        util::CharUtil<C> charutil;
      public:
        ostreamlogger(std::basic_ostream<C> &stream):mStream(stream),charutil() {}
        template <severity::Severity S>
        void log(std::basic_string<C> line) {
           threading::guard_if_needed<G> myguard;
           mStream << charutil.now() << charutil.sp_col_sp() << severity::asPrefix<S,C>() << charutil.sp_col_sp() << line;
        }
    };
  }
  template <typename L,typename C>
  class nullstreambuf : public std::basic_streambuf<C> {
      public:
        nullstreambuf(L &){}
        int overflow(int c) { return c; }
  };
  //A simple streambuf for any raw logger. Makes  things line oriented and cuts of lines at
  //some maximum length.
  template <typename L,severity::Severity S,typename C>
  class logstreambuf : public std::basic_streambuf<C> {
      L &mLogger;
      C data[256];
      size_t index;
      util::CharUtil<C> charutil;
    public:
      std::basic_streambuf<C>::setp;
      std::basic_streambuf<C>::setg;
      logstreambuf(L &logger):mLogger(logger),index(0),charutil(){
        setp(0,0);
        setg(0,0,0);
      }
      int overflow(int c) {
        setp(0,0);
        if (c != std::char_traits<C>::eof()) {
          data[index]=c;
          index++;
        }
        if ((c == charutil.newline()) || (index == 255) || (c == std::char_traits<C>::eof())) {
          data[index]=0;
          mLogger.template log<S>(std::basic_string<C>(data));
          index=0;
        }
        if (c != std::char_traits<C>::eof()) return 0;
          return c;
      }
  };

  template<bool C,typename T1,typename T2> struct if_c {
      typedef T1 type;
  };
  template<typename T1,typename T2> struct if_c<false,T1,T2> {
      typedef T2 type;
  };
  template <typename L,severity::Severity SbSeverity,severity::Severity ChosenSeverity,typename C>
  struct streambuf_selector { // nullstreambuf is used when streambuf severity greater than chosen severity
      typedef typename if_c< (SbSeverity<=ChosenSeverity), logstreambuf<L,SbSeverity,C>, nullstreambuf<L,C> >::type type;
  };
 
  //To give the logging lib a friendly API, we define a common abstract basecalass for all loggers.
  //This should allow passing a logger reference to the constructor of client classes without hooking those
  //client classes into our template hyrarchy.
  template <typename C>
  struct logger_base {
     virtual std::basic_ostream<C> &debug()=0;
     virtual std::basic_ostream<C> &info()=0;
     virtual std::basic_ostream<C> &notice()=0;
     virtual std::basic_ostream<C> &warning()=0;
     virtual std::basic_ostream<C> &err()=0;
     virtual std::basic_ostream<C> &crit()=0;
     virtual std::basic_ostream<C> &alert()=0;
     virtual std::basic_ostream<C> &emerg()=0;
     virtual ~logger_base(){}
  };

  //The actual logger.
  template <typename R,severity::Severity S,typename C>
  class logger: public logger_base<C> {
    R &mRawLogger;
    typename streambuf_selector<R,severity::DEBUG,S,C>::type mDebugSb;
    std::basic_ostream<C> mDebugStream;
    typename streambuf_selector<R,severity::INFO,S,C>::type mInfoSb;
    std::basic_ostream<C> mInfoStream;
    typename streambuf_selector<R,severity::NOTICE,S,C>::type mNoticeSb;
    std::basic_ostream<C> mNoticeStream;
    typename streambuf_selector<R,severity::WARNING,S,C>::type mWarningSb;
    std::basic_ostream<C> mWarningStream;
    typename streambuf_selector<R,severity::ERR,S,C>::type mErrSb;
    std::basic_ostream<C> mErrStream;
    typename streambuf_selector<R,severity::CRIT,S,C>::type mCritSb;
    std::basic_ostream<C> mCritStream;
    typename streambuf_selector<R,severity::ALERT,S,C>::type mAlertSb;
    std::basic_ostream<C> mAlertStream;
    typename streambuf_selector<R,severity::EMERG,S,C>::type mEmergSb;
    std::basic_ostream<C> mEmergStream;
  public: 
    logger(R &sl):mRawLogger(sl),mDebugSb(mRawLogger),mDebugStream(&mDebugSb),
                                 mInfoSb(mRawLogger),mInfoStream(&mInfoSb),
                                 mNoticeSb(mRawLogger),mNoticeStream(&mNoticeSb),
                                 mWarningSb(mRawLogger),mWarningStream(&mWarningSb),
                                 mErrSb(mRawLogger),mErrStream(&mErrSb),
                                 mCritSb(mRawLogger),mCritStream(&mCritSb),
                                 mAlertSb(mRawLogger),mAlertStream(&mAlertSb),
                                 mEmergSb(mRawLogger),mEmergStream(&mEmergSb)
                                 {}
    std::basic_ostream<C> &debug() {return mDebugStream;}
    std::basic_ostream<C> &info() {return mInfoStream;}
    std::basic_ostream<C> &notice() {return mNoticeStream;}
    std::basic_ostream<C> &warning() {return mWarningStream;}
    std::basic_ostream<C> &err() {return mErrStream;}
    std::basic_ostream<C> &crit() {return mCritStream;}
    std::basic_ostream<C> &alert() {return mAlertStream;}
    std::basic_ostream<C> &emerg() {return mEmergStream;}
  };
}
#endif

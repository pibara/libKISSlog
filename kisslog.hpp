//  Copyright (c) 2012, Rob J Meijer
//  Copyright (c) 2012, Evgeny Panasyuk
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.

#ifndef KISSLOG_HPP
#define KISSLOG_HPP
#include <kisslog/util.hpp>
#include <kisslog/concurrency.hpp>
#include <kisslog/severity.hpp>
#include <kisslog/rawlogger.hpp>
#include <kisslog/proto.hpp>
#include <string>
#include <streambuf>
#include <iostream>

namespace kisslog {
  //Streambuff implementation for null streams.
  template <typename RawloggerType,typename CharType,typename traits=std::char_traits<CharType> >
  class nullstreambuf : public std::basic_streambuf<CharType,traits > {
      public:
        nullstreambuf(RawloggerType &){}
        typename traits::int_type overflow(typename traits::int_type c) { return c; }
  };
  //A simple streambuf for any raw logger. Makes  things line oriented and cuts of lines at
  //some maximum length.
  template <typename RawloggerType,severity::Severity SeverityVal,typename CharType,typename traits=std::char_traits<CharType> >
  class logstreambuf : public std::basic_streambuf<CharType,traits> {
      RawloggerType &mLogger;
      CharType data[256];
      size_t index;
      util::CharUtil<CharType> charutil;
    public:
      using std::basic_streambuf<CharType,traits>::setp;
      using std::basic_streambuf<CharType,traits>::setg;
      logstreambuf(RawloggerType &logger):mLogger(logger),index(0),charutil(){
        setp(0,0);
        setg(0,0,0);
      }
      typename traits::int_type overflow(typename traits::int_type c) {
        setp(0,0);
        if (c != traits::eof()) {
          data[index]=c;
          index++;
        }
        if ((c == charutil.newline()) || 
            (index == 255) || 
            (c == traits::eof())) {
          data[index]=0;
          mLogger.template log<SeverityVal>(std::basic_string<CharType,traits>(data));
          index=0;
        }
        if (c != traits::eof()) return 0;
          return c;
      }
  };
  
  template<bool C,typename T1,typename T2> struct if_c {
      typedef T1 type;
  };
  template<typename T1,typename T2> struct if_c<false,T1,T2> {
      typedef T2 type;
  };
  template <typename RawloggerType,severity::Severity SbSeverity,severity::Severity ChosenSeverity,typename CharType>
  struct streambuf_selector { // nullstreambuf is used when streambuf severity greater than chosen severity
      typedef typename if_c< (SbSeverity<=ChosenSeverity), logstreambuf<RawloggerType,SbSeverity,CharType>, nullstreambuf<RawloggerType,CharType> >::type type;
  };
 
  //To give the logging lib a friendly API, we define a common abstract basecalass for all loggers.
  //This should allow passing a logger reference to the constructor of client classes without hooking those
  //client classes into our template hyrarchy.
  template <typename CharType=char>
  struct logger_base {
     virtual std::basic_ostream<CharType> &debug()=0;
     virtual std::basic_ostream<CharType> &info()=0;
     virtual std::basic_ostream<CharType> &notice()=0;
     virtual std::basic_ostream<CharType> &warning()=0;
     virtual std::basic_ostream<CharType> &err()=0;
     virtual std::basic_ostream<CharType> &crit()=0;
     virtual std::basic_ostream<CharType> &alert()=0;
     virtual std::basic_ostream<CharType> &emerg()=0;
     virtual ~logger_base(){}
  };

  //The actual logger.
  template <typename RawloggerType,severity::Severity Severity=severity::WARNING,typename CharType=char>
  class logger: public logger_base<CharType> {
    RawloggerType &mRawLogger;
    typename streambuf_selector<RawloggerType,severity::DEBUG,Severity,CharType>::type mDebugSb;
    std::basic_ostream<CharType> mDebugStream;
    typename streambuf_selector<RawloggerType,severity::INFO,Severity,CharType>::type mInfoSb;
    std::basic_ostream<CharType> mInfoStream;
    typename streambuf_selector<RawloggerType,severity::NOTICE,Severity,CharType>::type mNoticeSb;
    std::basic_ostream<CharType> mNoticeStream;
    typename streambuf_selector<RawloggerType,severity::WARNING,Severity,CharType>::type mWarningSb;
    std::basic_ostream<CharType> mWarningStream;
    typename streambuf_selector<RawloggerType,severity::ERR,Severity,CharType>::type mErrSb;
    std::basic_ostream<CharType> mErrStream;
    typename streambuf_selector<RawloggerType,severity::CRIT,Severity,CharType>::type mCritSb;
    std::basic_ostream<CharType> mCritStream;
    typename streambuf_selector<RawloggerType,severity::ALERT,Severity,CharType>::type mAlertSb;
    std::basic_ostream<CharType> mAlertStream;
    typename streambuf_selector<RawloggerType,severity::EMERG,Severity,CharType>::type mEmergSb;
    std::basic_ostream<CharType> mEmergStream;
  public: 
    logger(RawloggerType &sl):mRawLogger(sl),mDebugSb(mRawLogger),mDebugStream(&mDebugSb),
                                 mInfoSb(mRawLogger),mInfoStream(&mInfoSb),
                                 mNoticeSb(mRawLogger),mNoticeStream(&mNoticeSb),
                                 mWarningSb(mRawLogger),mWarningStream(&mWarningSb),
                                 mErrSb(mRawLogger),mErrStream(&mErrSb),
                                 mCritSb(mRawLogger),mCritStream(&mCritSb),
                                 mAlertSb(mRawLogger),mAlertStream(&mAlertSb),
                                 mEmergSb(mRawLogger),mEmergStream(&mEmergSb)
                                 {}
    std::basic_ostream<CharType> &debug() {return mDebugStream;}
    std::basic_ostream<CharType> &info() {return mInfoStream;}
    std::basic_ostream<CharType> &notice() {return mNoticeStream;}
    std::basic_ostream<CharType> &warning() {return mWarningStream;}
    std::basic_ostream<CharType> &err() {return mErrStream;}
    std::basic_ostream<CharType> &crit() {return mCritStream;}
    std::basic_ostream<CharType> &alert() {return mAlertStream;}
    std::basic_ostream<CharType> &emerg() {return mEmergStream;}
  };
}
#endif

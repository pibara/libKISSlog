//  Copyright (c) 2012, Rob J Meijer
//  Copyright (c) 2012, Evgeny Panasyuk
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.

#ifndef KISSLOG_HPP
#define KISSLOG_HPP
#include <kisslog/util.hpp>
#include <kisslog/concurrency.hpp>
#include <kisslog/severity.hpp>
#include <kisslog/rawlogger.hpp>
#include <string>
#include <streambuf>
#include <iostream>

namespace kisslog {
  template <typename L,typename C,typename traits=std::char_traits<C> >
  class nullstreambuf : public std::basic_streambuf<C,traits > {
      public:
        nullstreambuf(L &){}
        typename traits::int_type overflow(typename traits::int_type c) { return c; }
  };
  //A simple streambuf for any raw logger. Makes  things line oriented and cuts of lines at
  //some maximum length.
  template <typename L,severity::Severity S,typename C,typename traits=std::char_traits<C> >
  class logstreambuf : public std::basic_streambuf<C,traits> {
      L &mLogger;
      C data[256];
      size_t index;
      util::CharUtil<C> charutil;
    public:
      using std::basic_streambuf<C,traits>::setp;
      using std::basic_streambuf<C,traits>::setg;
      logstreambuf(L &logger):mLogger(logger),index(0),charutil(){
        setp(0,0);
        setg(0,0,0);
      }
      typename traits::int_type overflow(typename traits::int_type c) {
        setp(0,0);
        if (c != traits::eof()) {
          data[index]=c;
          index++;
        }
        if ((c == charutil.newline()) || 
            (index == 255) || 
            (c == traits::eof())) {
          data[index]=0;
          mLogger.template log<S>(std::basic_string<C,traits>(data));
          index=0;
        }
        if (c != traits::eof()) return 0;
          return c;
      }
  };

  template<bool C,typename T1,typename T2> struct if_c {
      typedef T1 type;
  };
  template<typename T1,typename T2> struct if_c<false,T1,T2> {
      typedef T2 type;
  };
  template <typename L,severity::Severity SbSeverity,severity::Severity ChosenSeverity,typename C>
  struct streambuf_selector { // nullstreambuf is used when streambuf severity greater than chosen severity
      typedef typename if_c< (SbSeverity<=ChosenSeverity), logstreambuf<L,SbSeverity,C>, nullstreambuf<L,C> >::type type;
  };
 
  //To give the logging lib a friendly API, we define a common abstract basecalass for all loggers.
  //This should allow passing a logger reference to the constructor of client classes without hooking those
  //client classes into our template hyrarchy.
  template <typename C=char>
  struct logger_base {
     virtual std::basic_ostream<C> &debug()=0;
     virtual std::basic_ostream<C> &info()=0;
     virtual std::basic_ostream<C> &notice()=0;
     virtual std::basic_ostream<C> &warning()=0;
     virtual std::basic_ostream<C> &err()=0;
     virtual std::basic_ostream<C> &crit()=0;
     virtual std::basic_ostream<C> &alert()=0;
     virtual std::basic_ostream<C> &emerg()=0;
     virtual ~logger_base(){}
  };

  //The actual logger.
  template <typename R,severity::Severity S=severity::WARNING,typename C=char>
  class logger: public logger_base<C> {
    R &mRawLogger;
    typename streambuf_selector<R,severity::DEBUG,S,C>::type mDebugSb;
    std::basic_ostream<C> mDebugStream;
    typename streambuf_selector<R,severity::INFO,S,C>::type mInfoSb;
    std::basic_ostream<C> mInfoStream;
    typename streambuf_selector<R,severity::NOTICE,S,C>::type mNoticeSb;
    std::basic_ostream<C> mNoticeStream;
    typename streambuf_selector<R,severity::WARNING,S,C>::type mWarningSb;
    std::basic_ostream<C> mWarningStream;
    typename streambuf_selector<R,severity::ERR,S,C>::type mErrSb;
    std::basic_ostream<C> mErrStream;
    typename streambuf_selector<R,severity::CRIT,S,C>::type mCritSb;
    std::basic_ostream<C> mCritStream;
    typename streambuf_selector<R,severity::ALERT,S,C>::type mAlertSb;
    std::basic_ostream<C> mAlertStream;
    typename streambuf_selector<R,severity::EMERG,S,C>::type mEmergSb;
    std::basic_ostream<C> mEmergStream;
  public: 
    logger(R &sl):mRawLogger(sl),mDebugSb(mRawLogger),mDebugStream(&mDebugSb),
                                 mInfoSb(mRawLogger),mInfoStream(&mInfoSb),
                                 mNoticeSb(mRawLogger),mNoticeStream(&mNoticeSb),
                                 mWarningSb(mRawLogger),mWarningStream(&mWarningSb),
                                 mErrSb(mRawLogger),mErrStream(&mErrSb),
                                 mCritSb(mRawLogger),mCritStream(&mCritSb),
                                 mAlertSb(mRawLogger),mAlertStream(&mAlertSb),
                                 mEmergSb(mRawLogger),mEmergStream(&mEmergSb)
                                 {}
    std::basic_ostream<C> &debug() {return mDebugStream;}
    std::basic_ostream<C> &info() {return mInfoStream;}
    std::basic_ostream<C> &notice() {return mNoticeStream;}
    std::basic_ostream<C> &warning() {return mWarningStream;}
    std::basic_ostream<C> &err() {return mErrStream;}
    std::basic_ostream<C> &crit() {return mCritStream;}
    std::basic_ostream<C> &alert() {return mAlertStream;}
    std::basic_ostream<C> &emerg() {return mEmergStream;}
  };
}
#endif

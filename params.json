{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"LibKISSlog","body":"### The KISS Logging template-library for C++\r\nLibKISSlog is a trivial light-weight C++ template library that was designed and written according to the KISS ( Keep It Simple & Straightforward) principle. The library leans heavily on the STL for keeping its implementation as simple as its usage, and tries to provide C++ developers with a light-weight, paradigm-pure and flexible alternative to logging libraries that use design and/or implementation decisions that at least the author of LibKISSlog believes to be questionable. Its easiest to explain why LibKISSlog would be suitable for your needs by listing the things that LibKISSlog does _NOT_ choose to use or do: \r\n\r\n* Uses no singletons or other forms of mutable global state.\r\n* Uses no macro's\r\n* Doesn't try to fit the Java run-time everything model onto a C++ library.\r\n* Doesn't try to be a Java style (bloated) framework.\r\n* Doesn't make the choice for you whether you need thread safety.\r\n* Does not compromise on simplicity in order to facilitate questionable inner-loop logging practices.\r\n\r\n### Writing your own raw logger.\r\nThe first thing you will want to do when using LibKISSlog is determine if you ont to use one of the two packaged raw loggers, or if you want to provide your own. Lets first assume you want full control and want to do things the harder (yet still simple) way, and want to build your own raw logger in order to fully control the output of your logger. \r\n\r\nA raw logger can either be a normal class or a template class that implements a _log_ template method. LibKISSlog defines a set of log level classes that are to be used by libKISSlog as template parameters for the _log_ method of the raw logger. These classes have two class methods that you may choose to use when writing your own raw logger:\r\n\r\n* _asPrefix()_ : This class method returns a string containing the name of the log level.\r\n* _asSyslogLevel()_ : This class method returns an integer representing the log level as a syslog API compatible integer representation. \r\n\r\nHere would be an example of a dumb and useless raw logger that logs to cerr with a line number prepended:\r\n\r\n\r\n\r\n    class myrawlogger {\r\n           size_t mLineno;\r\n       public:\r\n           myrawlogger():mLineNo(0){}\r\n           template <typename T>\r\n           void log(std::string line) {\r\n              mLineno++;\r\n              std::cerr << mLineNo << \":\" << T::asPrefix() << line;\r\n           }\r\n    };\r\n\r\n\r\nNote that if you write a raw logger that you want to re-use in several projects, especially if you are using thread-unsafe API calls and want to be able to re-use your custom raw logger in both single threaded and multi threaded application, it is sugested that you implement your raw logger as a template class basically like this:\r\n\r\n\r\n    template <typename G>\r\n    class base_myrawlogger {\r\n           size_t mLineno;\r\n       public:\r\n           base_myrawlogger():mLineNo(0){}\r\n           template <typename T>\r\n           void log(std::string line) {\r\n              threading::guard_if_needed<G> myguard;\r\n              mLineno++;\r\n              std::cerr << mLineNo << \":\" << T::asPrefix() << line;\r\n           }\r\n    };\r\n\r\n\r\nNow before you instantiate your logger its a good idea to create a typedef approprite for your program. If you are working on a single threaded program you would say:\r\n\r\n    typedef base_myrawlogger<kisslog::threading::SINGLE> myrawlogger;\r\n\r\nWhile in a multi-threaded project you would use:\r\n\r\n    typedef base_myrawlogger<kisslog::threading::MULTI> myrawlogger;\r\n\r\nThe idea behind this is that when you don't _need_ thread-safety, than you don't pay any performance penalty for it either.\r\n\r\n### Using the syslog raw logger\r\nWhile the flexibility of writing your own raw logging is great, often you will just want to get the show on the road quickly and you would thus like to settle for one of the two raw loggers that come with libKISSlog. The first of these is _kisslog::rawlogger::sysloglogger_. Just as we did with our own raw logger, you will want to create an appropriate typedef for your raw logger. Note that the sysloglogger raw logger template takes an additional template parameter: the _facility_. LibKISSlog defines a set of parameter classes for picking the facility that is a subset of the facilities defined by syslog. So basically next to picking single or multi threading, the typedef also picks the facility you will be using. An example typedef could be:\r\n\r\n    typedef kisslog::rawlogger::sysloglogger<\r\n              kisslog::facility::USER,\r\n              kisslog::threading::SINGLE\r\n            > syslograwlogger;\r\n\r\nThis typedef defines the type syslograwlogger to be a raw non thread-safe syslog logger that logs to the _USER_ syslog facility.\r\n\r\n###Using the ostream raw logger\r\nWhile on most systems that support syslog you will probably want to use the syslog logger in production, on Windows systems and on your development environment its likely you will often want to log to either a file or the standard output or error stream. To facilitate this, libKISSlog defines a simple raw logger for logging to a wrapped ostream. Like our example and like the syslog raw logger, the _kisslog::rawlogger::ostreamlogger_ raw logger takes a threading related template parameter. Again we will thus want to use a typedef to define the apropriate type for our raw logger for our project.\r\n\r\n    typedef kisslog::rawlogger::ostreamlogger<\r\n              kisslog::threading::SINGLE\r\n            > ostreamrawlogger;\r\n\r\n### Typedeffing our real logger\r\nSo far all we've basically done is defining a type for a raw logger that should be used by our actual logger. Before we can instantiate our raw logger and use it to instantiate a real logger, there remains one thing to do. We need to also typedef a shorthand type for our actual logger.\r\nThe _kisslog::logger_ class template takes two template arguments. The first template argument is the type of the raw logger we just defined. The second template argument is the _minimal_ log level for this logger for what log lines will actually get logged. This last template parameter basically implies that you can switch between doing fully verbose debug logging and logging that only does WARNING and above by changing a typedef. A real logger typedef may look something like:\r\n\r\n    typedef kisslog::logger<\r\n              myrawlogger,\r\n              kisslog::severity::WARNING\r\n            > mywarnlogger;\r\n \r\n\r\n### Instantiating and using the loggers\r\nNow that we have our typedefs in order (myrawlogger and warnlogger), we can instantiate our logger and use it.\r\n\r\n\r\n    myrawlogger rawlogger;\r\n    mywarnlogger warnlogger(rawlogger);\r\n    ..\r\n    warnlogger.err() << \"Logging is simple \" << 42 << std::endl;\r\n    warnlogger.debug() << \"This line won't be logged.\" << std::endl;\r\n\r\nThe logger defines a small set of methods, one for each log level, that all return an ostream reference.\r\nGiven our typedef for mywarnlogger defining _kisslog::severity::WARNING_ as minimal level for logging, the warnlogger.err() method will return a stream reference that maps to our raw logger being invoked, while the warnlogger.debug() invocation will return a null stream.\r\n\r\n### Word of caution regarding debug logging and performance.\r\nPlease note that while our logger will return null streams that are relatively efficient, the sheer volume of debug logs might turn many operator<<() invocations done in inner loops into a major performance bottleneck. Addressing these issues is beyond the scope of libKISSlog or any other logging library that chooses to use a streaming interface. It is thus sugested that you should probably :\r\n\r\n* Use old and ugly #ifdef constructs for debug logs in inner loops.\r\n* Never use logs above the debug level in your inner loops.\r\n\r\nLogging code in inner loops should thus look something like this: \r\n\r\n       #ifdef DEBUG_INNER_LOOPS\r\n         debuglogger.debug() << \"Log in performance critical inner loops.\"\r\n       #endif\r\n\r\n### Passing loggers around\r\nThe libKISSlog API does out of principle not supply any singleton interface and does not use any kind of global mutable state under the hood. Instead, libKISSlog promotes the use of constructor based dependency injection. To accomodate this, any concrete kisslog::logger class is a subclass of the abstract _kisslog::logger_base_ class. This basically allows for constructs like:\r\n\r\n\r\n    class Foo {\r\n        kisslog::logger_base &mLogger;\r\n      public:\r\n        Foo(kisslog::logger_base &logger):mLogger(logger) {}\r\n        void testlog() {\r\n            mLogger.debug() << \"Foo has something uninteresting to say\" << std::endl;\r\n            mLogger.crit() << \"Foo is in big problems.\" << std::endl;\r\n        }\r\n    };\r\n    ..\r\n    Foo foo(warnlogger);\r\n    ..\r\n    foo.testlog();\r\n\r\nNote that Foo does not need to know what type of logger its being passed here. This also, next to making dependencies more explicit (what is good), allows for flexibility in what level of logging is used by what sub systems without using bloated Log4J style frameworks, simply by passing different loggers (with different minimum log levels) to the constructors of the different sub-systems:\r\n\r\n    Foo foo(warnlogger);\r\n    Bar bar(debuglogger);\r\n    ..\r\n    foo.testlog();\r\n    bar.testlog();\r\n\r\n\r\nIn the above situation, foo will not log any DEBUG, INFO or NOTICE level log lines, while bar will.\r\n### Known issues\r\nThe following issues are currently known with libKISSlog, some may be fixed later.\r\n\r\n* Compiling and using libKISSlog on the windows platform is currently completely unvalidated and completely untested. It may compile and run, it may compile and not run, or it may not even compile. \r\n* What is currently sure about windows is that the raw syslog logger isn't available, and that only compiling for C++11 might possibly work (no C++03 as a result of missing mutex code for non pthread systems).\r\n* There is currently no support for using wchar as basis. \r\n\r\nAs you can see, all issues today have to do with windows portability. The author currently has no access to a Windows development environment with C++11 support that is needed to develop and test on that platform. If any windows C++ developer would like to help out, please fork the project on github and drop me a pull request if you have anything that would help in portability to windows.","tagline":"A trivial but powerful C++ logging template-library. ","google":""}
//  Copyright (c) 2012, Rob J Meijer
//
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.

#ifndef LOG_LITE_HPP
#define LOG_LITE_HPP
#ifndef WIN32
#include <syslog.h>
#endif

#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L
#include <mutex>
#else
#ifndef WIN32
#include <pthread.h>
#else 
#error "On windows you need to compile as C++11 for loglite to compile"
#endif
#endif

#include <string.h>
#include <string>
#include <streambuf>
#include <iostream>
namespace loglite {
  //An list of syslog facilities as simple classes. Note that these are not all possible
  //facilities, just the one a typical user space program will be using.
  namespace facility {
    struct DAEMON {
      static int asSyslogFacility() {
        return LOG_DAEMON;
      }
    };
    struct LOCAL0 {
      static int asSyslogFacility() {
        return LOG_LOCAL0;
      }
    };
    struct LOCAL1 {
      static int asSyslogFacility() {
        return LOG_LOCAL1;
      }
    };
    struct LOCAL2 {
      static int asSyslogFacility() {
        return LOG_LOCAL2;
      }
    };
    struct LOCAL3 {
      static int asSyslogFacility() {
        return LOG_LOCAL3;
      }
    };
    struct LOCAL4 {
      static int asSyslogFacility() {
        return LOG_LOCAL4;
      }
    };
    struct LOCAL5 {
      static int asSyslogFacility() {
        return LOG_LOCAL5;
      }
    };
    struct LOCAL6 {
      static int asSyslogFacility() {
        return LOG_LOCAL6;
      }
    };
    struct LOCAL7 {
      static int asSyslogFacility() {
        return LOG_LOCAL7;
      }
    };
    struct USER {
      static int asSyslogFacility() {
        return LOG_USER;
      }
    }; 
  }
  //Some helper classes for allowing multi threading (in a crude way) only when needed.
  namespace threading {
    struct SINGLE{};
    struct MULTI{};
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L
    class guard {
        static std::mutex mGlobalMutex; 
      public:
        guard() {
          mGlobalMutex.lock();
        }
        ~guard() {
          mGlobalMutex.unlock();
        }       
    };
#else
#ifndef WIN32
    class guard {
        static pthread_mutex_t mGlobalMutex; 
      public:
        guard() {
          pthread_mutex_lock(&mGlobalMutex);
        }
        ~guard() {
          pthread_mutex_unlock(&mGlobalMutex);
        }       
    };
#else
#error "On windows you need to compile as C++11 for loglite to compile" 
#endif
#endif
    template <typename T>
    class guard_if_needed {};
    template <>
    class guard_if_needed <MULTI> {
        guard mGuard;      
    };
  }
  //A list of log levels as simple classes.
  namespace severity {
    struct DEBUG {
       static int asSyslogLevel() {
         return LOG_DEBUG;
       }
       static std::string asPrefix() {
          return "DEBUG";
       }
    };
    struct INFO {
       static int asSyslogLevel() {
         return LOG_INFO;
       }
       static std::string asPrefix() {
          return "INFO";
       }
    };
    struct NOTICE {
       static int asSyslogLevel() {
         return LOG_NOTICE;
       }
       static std::string asPrefix() {
          return "NOTICE";
       }
    };
    struct WARNING {
       static int asSyslogLevel() {
         return LOG_WARNING;
       }
       static std::string asPrefix() {
          return "WARNING";
       }
    };
    struct ERR {
       static int asSyslogLevel() {
         return LOG_ERR;
       }
       static std::string asPrefix() {
          return "ERR";
       }
    };
    struct CRIT {
       static int asSyslogLevel() {
         return LOG_CRIT;
       }
       static std::string asPrefix() {
          return "CRIT";
       }
    };
    struct ALERT {
       static int asSyslogLevel() {
         return LOG_ALERT;
       }
       static std::string asPrefix() {
          return "ALERT";
       }
    };
    struct EMERG {
       static int asSyslogLevel() {
         return LOG_EMERG;
       }
       static std::string asPrefix() {
          return "EMERG";
       }
    };
  }
  //Some raw loggers, well one actually, currently.There is only a syslog raw logger now but we could add a stream logger here maybe.
  namespace rawlogger {
#ifndef WIN32
    template <typename F,typename G>
    class sysloglogger {
        std::string mIdent;
      public:
        sysloglogger(std::string ident):mIdent(ident) {
          openlog(mIdent.c_str(),LOG_PID, F::asSyslogFacility());    
        } 
        ~sysloglogger() {
           closelog();
        }

        template <typename T,typename R>
        void log(std::string line) {
           threading::guard_if_needed<G> myguard;
           syslog(T::asSyslogLevel(),"%s",line.c_str());
        }
    };
#endif
  }
  class nullstreambuf : public std::streambuf {
      public:
        int overflow(int c) { return c; }
  };
  //A simple streambuf for any raw logger. Makes  things line oriented and cuts of lines at
  //some maximum length.
  template <typename L,typename S,typename R>
  class logstreambuf : public std::streambuf {
      L &mLogger;
      std::string mPrefix;
      char data[256];
      size_t index;
    public:
      logstreambuf(L logger):mLogger(logger){
        setp(0,0);
        setg(0,0,0);
        index=0;
      }
      int overflow(int c) {
        setp(0,0);
        if (c != std::char_traits<char>::eof()) {
          data[index]=c;
          index++;
        }
        if ((c == '\n') || (index == 255) || (c == std::char_traits<char>::eof())) {
          data[index]=0;
          mLogger.template log<S,R>((std::string(S::asPrefix()) + " : " + data).c_str());
          index=0;
        }
        if (c != std::char_traits<char>::eof()) return 0;
          return c;
      }
  };
  //Set of partial specializations that keep the above overflow function from being used by log streams that should be filtered.
  template <typename L>
  class logstreambuf<L,severity::DEBUG,severity::INFO> : public nullstreambuf {public: logstreambuf(L logger){}}; 
  template <typename L>
  class logstreambuf<L,severity::DEBUG,severity::NOTICE> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::DEBUG,severity::WARNING> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::DEBUG,severity::ERR> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::DEBUG,severity::CRIT> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::DEBUG,severity::ALERT> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::DEBUG,severity::EMERG> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::INFO,severity::NOTICE> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::INFO,severity::WARNING> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::INFO,severity::ERR> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::INFO,severity::CRIT> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::INFO,severity::ALERT> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::INFO,severity::EMERG> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::NOTICE,severity::WARNING> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::NOTICE,severity::ERR> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::NOTICE,severity::CRIT> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::NOTICE,severity::ALERT> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::NOTICE,severity::EMERG> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::WARNING,severity::ERR> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::WARNING,severity::CRIT> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::WARNING,severity::ALERT> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::WARNING,severity::EMERG> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::ERR,severity::CRIT> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::ERR,severity::ALERT> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::ERR,severity::EMERG> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::CRIT,severity::ALERT> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::CRIT,severity::EMERG> : public nullstreambuf {public: logstreambuf(L logger){}};
  template <typename L>
  class logstreambuf<L,severity::ALERT,severity::EMERG> : public nullstreambuf {public: logstreambuf(L logger){}};
 
  //To give the logging lib a friendly API, we define a common abstract basecalass for all loggers.
  //This should allow passing a logger reference to the constructor of client classes without hooking those
  //client classes into our template hyrarchy.
  struct logger_base {
     virtual std::ostream &debug()=0;
     virtual std::ostream &info()=0;
     virtual std::ostream &notice()=0;
     virtual std::ostream &warning()=0;
     virtual std::ostream &err()=0;
     virtual std::ostream &crit()=0;
     virtual std::ostream &alert()=0;
     virtual std::ostream &emerg()=0;
  };

  //The actual logger.
  template <typename R,typename S>
  class logger: public logger_base {
    R &mRawLogger;
    logstreambuf<R,severity::DEBUG,S> mDebugSb;
    std::ostream mDebugStream;
    logstreambuf<R,severity::INFO,S> mInfoSb;
    std::ostream mInfoStream;
    logstreambuf<R,severity::NOTICE,S> mNoticeSb;
    std::ostream mNoticeStream;
    logstreambuf<R,severity::WARNING,S> mWarningSb;
    std::ostream mWarningStream;
    logstreambuf<R,severity::ERR,S> mErrSb;
    std::ostream mErrStream;
    logstreambuf<R,severity::CRIT,S> mCritSb;
    std::ostream mCritStream;
    logstreambuf<R,severity::ALERT,S> mAlertSb;
    std::ostream mAlertStream;
    logstreambuf<R,severity::EMERG,S> mEmergSb;
    std::ostream mEmergStream;
  public: 
    logger(R &sl):mRawLogger(sl),mDebugSb(mRawLogger),mDebugStream(&mDebugSb),
                                 mInfoSb(mRawLogger),mInfoStream(&mInfoSb),
                                 mNoticeSb(mRawLogger),mNoticeStream(&mNoticeSb),
                                 mWarningSb(mRawLogger),mWarningStream(&mWarningSb),
                                 mErrSb(mRawLogger),mErrStream(&mErrSb),
                                 mCritSb(mRawLogger),mCritStream(&mCritSb),
                                 mAlertSb(mRawLogger),mAlertStream(&mAlertSb),
                                 mEmergSb(mRawLogger),mEmergStream(&mEmergSb)
                                 {}
    std::ostream &debug() { return mDebugStream;}
    std::ostream &info() { return mInfoStream;}
    std::ostream &notice() { return mNoticeStream;}
    std::ostream &warning() { return mWarningStream;}
    std::ostream &err() { return mErrStream;}
    std::ostream &crit() { return mCritStream;}
    std::ostream &alert() { return mAlertStream;}
    std::ostream &emerg() { return mEmergStream;}
  };
}
#endif
